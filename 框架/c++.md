# 一、面向对象设计

### 1、头文件

![image-20230607225329762](img/c++/image-20230607225329762.png)

### 2、模板

![image-20230607225548518](img/c++/image-20230607225548518.png)

### 3、inline函数

在类内部定义的函数，有机会成为内敛函数。外部定义要在函数前加上inline关键字。

### 4、构造函数

![image-20230609201218735](img/c++/image-20230609201218735.png)

### 5、函数重载

要求形参的类型不同、个数不同、顺序不同；

注意：返回值和访问修饰符不同不算。

![image-20230609201521955](img/c++/image-20230609201521955.png)

### 6、常量const

对不会改变数据内容的函数，在函数后面加上const关键字，注意添加位置。

![image-20230609203630282](img/c++/image-20230609203630282.png)

### 7、值传递和引用传递

传引用更快，但是不希望被修改，可以传const的引用。

![image-20230609204047782](img/c++/image-20230609204047782.png)

返回值的传递也尽量用引用。

![image-20230609204627910](img/c++/image-20230609204627910.png)

注意不可返回引用的情况：返回的对象是临时对象或者local对象，在函数结束时生命周期结束，导致返回的是死亡对象的引用。

### 8、友元friend

友元函数可以自由取得friend的private成员。

![image-20230609205151108](img/c++/image-20230609205151108.png)

注意：相同class的各个object互为友元。

![image-20230609210116025](img/c++/image-20230609210116025.png)

### 9、操作符重载

成员函数，有this

![image-20230609215751521](img/c++/image-20230609215751521.png)

非成员函数，无this

![image-20230609220213791](img/c++/image-20230609220213791.png)

注意，上面三者都不能返回引用，因为都是局部变量。

如果将<<操作符重载写为成员函数，要知道操作符都是作用在左边的，那就会变成![image-20230610163011614](img/c++/image-20230610163011614.png)不符合使用习惯。

所以<<等特殊操作符只能是全局函数来重载，因为涉及到cout，它是在ostream类中的。

![image-20230609223904073](img/c++/image-20230609223904073.png)

### 10、BigTree

三个特殊函数（Big Three）：拷贝构造、拷贝赋值、析构函数。

带指针的对象要包含上述三个特殊函数。

![image-20230610194747969](img/c++/image-20230610194747969.png)

![image-20230610194515903](img/c++/image-20230610194515903.png)

![image-20230610194539013](img/c++/image-20230610194539013.png)

![image-20230610194556875](img/c++/image-20230610194556875.png)

### 11、stack和heap

![image-20230610195614567](img/c++/image-20230610195614567.png)

上述作用域里，c1放在stack，p放在heap，当离开作用域，c1会自动释放掉（析构函数），而p需要手动delete。

所谓内存泄露，是离开作用域之后，指针死亡了，但是指针所指向的空间还在，失去控制。

### 12、static对象生命周期

直到整个程序结束才会调用析构函数。

![image-20230610195858234](img/c++/image-20230610195858234.png)

### 13、全局变量生命周期

![image-20230610204415966](img/c++/image-20230610204415966.png)

### 14、new 的过程

![image-20230610204731107](img/c++/image-20230610204731107.png)

new 的过程可以分为三步，① 分配内存空间，② 数据转型，③ 通过指针调用构造函数。

### 15、delete的过程

![image-20230610205811357](img/c++/image-20230610205811357.png)

先执行析构函数（释放指针所指向空间），再释放内存（指针）。

注意：array new一定要搭配array delete，不然会内存泄露![image-20230612220305751](img/c++/image-20230612220305751.png)



