# 力扣热题100

## 一、动态规划

### 题目5 [最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring/?favorite=2cktkvj)

```java
class Solution {
    /**
    *  算法思想为中心扩散，从每个下标的字符向两边扩散，记录回文串的长度
    */
    public String longestPalindrome(String s) {
        if(s == null || s.length() < 2) return s;
        int maxLength = 1;
        int begin = 0;
        for(int i = 0; i < s.length(); i++) {
            int len1 = expend(s, i, i); //以i下标向左、向右扩散
            int len2 = expend(s, i, i+1); //以i下标向左，以i+1下标向右扩散
            int len3 = Math.max(len1, len2);
            if(len3 > maxLength) {
                maxLength = len3;
                begin = i - ((len3 - 1) / 2); //i下标是中心位置，要记录起点的位置
            }
        }
        return s.substring(begin, begin+maxLength);
    }

    private int expend(String s, int left, int right) {
        while(left >= 0 && right < s.length()) {
            if(s.charAt(left) != s.charAt(right)) break;
            left--;
            right++;
        }
        return right - left - 1;
    }
}
```

### 题目53 [最大子数组和](https://leetcode.cn/problems/maximum-subarray/?favorite=2cktkvj)

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int preSum = nums[0];
        int max = nums[0];
        for(int i = 1; i < nums.length; i++) {
            if(preSum >= 0) {
                preSum += nums[i];
            } else {
                preSum = nums[i];
            }
            max = Math.max(max, preSum);
        }
        return max;
    }
}
```

### 题目62 [不同路径](https://leetcode.cn/problems/unique-paths/?favorite=2cktkvj)

```java
class Solution {
    public int uniquePaths(int m, int n) {
        int[][] dp = new int[m][n];
        for(int i = 0; i < m; i++) dp[i][0] = 1;
        for(int i = 0; i < n; i++) dp[0][i] = 1;
        for(int i = 1; i < m; i++) {
            for(int j = 1; j < n; j++) {
                dp[i][j] = dp[i-1][j] + dp[i][j-1];
            }
        }
        return dp[m-1][n-1];
    }
}
```

### 题目64 [最小路径和](https://leetcode.cn/problems/minimum-path-sum/?favorite=2cktkvj)

```java
class Solution {
    public int minPathSum(int[][] grid) {
        int rows = grid.length;
        int cols = grid[0].length;
        int[][] dp = new int[rows][cols];
        dp[0][0] = grid[0][0];
        for(int i = 1; i < rows; i++) dp[i][0] = dp[i-1][0] + grid[i][0];
        for(int i = 1; i < cols; i++) dp[0][i] = dp[0][i-1] + grid[0][i];
        for(int i = 1; i < rows; i++) {
            for(int j = 1; j < cols; j++) {
                dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
            }
        }
        return dp[rows-1][cols-1];
    }
}
```

### 题目70 [爬楼梯](https://leetcode.cn/problems/climbing-stairs/?favorite=2cktkvj)

```java
class Solution {
    public int climbStairs(int n) {
        int pp = 1;
        int p = 2;
        if(n == 1) return pp;
        if(n == 2) return p;
        int res = 0;
        for(int i = 3; i <= n; i++) {
            res = pp + p;
            pp = p;
            p = res;
        }
        return res;
    }
}
```

### 题目96 [不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/?favorite=2cktkvj)

```java
class Solution {
    public int numTrees(int n) {
        if(n == 1) return 1;
        if(n == 2) return 2;
        int[] dp = new int[n+1];
        dp[0] = 1;
        dp[1] = 1;
        dp[2] = 2;
        // 一共有i个节点
        for(int i = 3; i <= n; i++) {
            // j号节点作为头结点
            for(int j = 1; j <= i; j++) {
                // 左子树有j-1个节点，右子树有i-j个节点
                // 左子树有dp[j-1]种情况，右子树有dp[i-j]个情况
                // 所有以j号节点开头的情况下共有dp[j-1]*dp[i-j]个情况
                dp[i] += dp[j-1] * dp[i-j]; 
            }
        }
        return dp[n];
    }
}
```

### 题目121 [买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/?favorite=2cktkvj)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int minPrice = prices[0];
        int max = 0;
        for(int i = 1; i < prices.length; i++) {
            if(prices[i] < minPrice) {
                minPrice = prices[i];
                continue;
            }
            max = Math.max(max, prices[i] - minPrice);
        }
        return max;
    }
}
```

### 题目139 [单词拆分](https://leetcode.cn/problems/word-break/?favorite=2cktkvj)

```java
class Solution {
    public boolean wordBreak(String s, List<String> wordDict) {
        int len = s.length();
        Set<String> set = new HashSet<>();
        for(int i = 0; i < wordDict.size(); i++) {
            set.add(wordDict.get(i));
        }
        
        boolean[] dp = new boolean[len+1];
        dp[0] = true;
        for(int i = 1; i <= len; i++) {
            for(int j = 0; j < i; j++) {
                if(dp[j] && set.contains(s.substring(j, i))) dp[i] = true;
            }
        }

        return dp[len];
    }
}
```

### 题目152 [乘积最大子数组](https://leetcode.cn/problems/maximum-product-subarray/?favorite=2cktkvj)

```java
class Solution {
    public int maxProduct(int[] nums) {
        int len = nums.length;
        int[][] dp = new int[len][2];
        dp[0][0] = nums[0];
        dp[0][1] = nums[0];
        for(int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i-1][0]*nums[i], Math.max(dp[i-1][1]*nums[i], nums[i]));
            dp[i][1] = Math.min(dp[i-1][1]*nums[i], Math.min(dp[i-1][0]*nums[i], nums[i]));
        }
        int max = dp[0][0];
        for(int i = 1; i < len; i++) {
            max = Math.max(max, dp[i][0]);
        }
        return max;
    }
}
```

### 题目198 [打家劫舍](https://leetcode.cn/problems/house-robber/?favorite=2cktkvj)

```java
class Solution {
    public int rob(int[] nums) {
        int len = nums.length;
        int[] dp = new int[len+1];
        dp[1] = nums[0];
        for(int i = 2; i <= len; i++) {
            dp[i] = Math.max(dp[i-1], dp[i-2]+nums[i-1]);
        }
        return dp[len];
    }
}
```

### 题目221 [最大正方形](https://leetcode.cn/problems/maximal-square/?favorite=2cktkvj)

```java
class Solution {
    public int maximalSquare(char[][] matrix) {
        int[][] dp = new int[matrix.length][matrix[0].length];
        int max = 0;
        for (int i = 0; i < matrix.length; i++) {
            dp[i][0] = matrix[i][0] == '1' ? 1 : 0;
            if (dp[i][0] > max)
                max = dp[i][0];
        }
        for (int i = 0; i < matrix[0].length; i++) {
            dp[0][i] = matrix[0][i] == '1' ? 1 : 0;
            if (dp[0][i] > max)
                max = dp[0][i];
        }

        for (int i = 1; i < matrix.length; i++) {
            for (int j = 1; j < matrix[0].length; j++) {
                if (matrix[i][j] == '1') {
                    dp[i][j] = Math.min(dp[i-1][j], Math.min(dp[i-1][j-1], dp[i][j-1]))+1;
                    if (dp[i][j] > max)
                        max = dp[i][j];
                } else {
                    dp[i][j] = 0;
                }
            }
        }

        return max*max;
    }
}
```

### 题目279 [完全平方数](https://leetcode.cn/problems/perfect-squares/?favorite=2cktkvj)

```java
class Solution {
    public int numSquares(int n) {
        int[] dp = new int[n+1];
        for(int i = 1; i <= n; i++) {
            int min = Integer.MAX_VALUE;
            for(int j = 1; j * j <= i; j++) {
                min = Math.min(min, dp[i-j*j]);
            }
            dp[i] = min + 1;
        }
        return dp[n];
    }
}
```

### 题目300 [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/?favorite=2cktkvj)

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        int maxLen = 1;
        int[] dp = new int[len];
        int min = nums[0];
        Arrays.fill(dp, 1);
        for(int i = 1; i < len; i++) {
            if(nums[i] <= min) {
                min = nums[i];
                dp[i] = 1;
            } else {
                for(int j = 0; j < i; j++) {
                    if(nums[j] < nums[i]) {
                        dp[i] = Math.max(dp[i], dp[j]+1);
                    }
                }
            }
            maxLen = Math.max(maxLen, dp[i]);
        }
        return maxLen;
    }
}
```

### 题目309 [最佳买卖股票时机含冷冻期](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/?favorite=2cktkvj)

```java
class Solution {
    public int maxProfit(int[] prices) {
        int len = prices.length;
        // dp[i][0]表示第i天持有股票的利润；
        // dp[i][1]表示第i天卖出股票后的利润；
        // dp[i][2]表示第i天未持有股票的利润；
        int[][] dp = new int[len][3];
        // 第0天买入股票需要减去股票费用；
        dp[0][0] = -prices[0];
        for(int i = 1; i < len; i++) {
            // 第i天持有股票：要么是前一天已经持有，要么是前一天未持有，第i天买入；
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][2]-prices[i]);
            // 第i天卖出股票：前一天持有，第i天卖出获取利润；
            dp[i][1] = dp[i-1][0] + prices[i];
            // 第i天未持有股票：前一天未持有，前一天刚卖出；
            dp[i][2] = Math.max(dp[i-1][2], dp[i-1][1]);
        }
        return Math.max(dp[len-1][0], Math.max(dp[len-1][1], dp[len-1][2]));
    }
}
```

### 题目322 [零钱兑换](https://leetcode.cn/problems/coin-change/?favorite=2cktkvj)

```java
class Solution {
    public int coinChange(int[] coins, int amount) {
        int[] dp = new int[amount+1];
        Arrays.fill(dp, Integer.MAX_VALUE);
        dp[0] = 0;
        for(int i = 1; i <= amount; i++) {
            for(int j = 0; j < coins.length; j++) {
                if(i - coins[j] >= 0 && dp[i-coins[j]] != Integer.MAX_VALUE)
                    dp[i] = Math.min(dp[i], dp[i-coins[j]]+1);
            }
        }
        if(dp[amount] == Integer.MAX_VALUE) dp[amount] = -1;
        return dp[amount];
    }
}
```

### 题目337 [打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/?favorite=2cktkvj)

```java
class Solution {
    public int rob(TreeNode root) {
        int[] res = f(root);
        return Math.max(res[0], res[1]);
    }

    private int[] f(TreeNode root) {
        if(root == null) return new int[2];
        // res[0]表示不偷当前节点
        // res[1]表示偷当前节点
        int[] res = new int[2];
        int[] left = f(root.left);
        int[] right = f(root.right);
        res[0] = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);
        res[1] = left[0] + right[0] + root.val;
        return res;
    }
}
```

### 题目338 [比特位计数](https://leetcode.cn/problems/counting-bits/?favorite=2cktkvj)

```java
class Solution {
    public int[] countBits(int n) {
        int[] dp = new int[n+1];
        for(int i = 1; i <= n; i++) {
            if(i % 2 == 1) {
                dp[i] = dp[i/2]+1;
            } else dp[i] = dp[i/2];
        }
        return dp;
    }
}
```

### 题目416 [分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/?favorite=2cktkvj)

```java
class Solution {
    public boolean canPartition(int[] nums) {
        int len = nums.length;
        if (len == 1) return false;
        int sum = 0;
        for (int num : nums) { sum += num; }
        if (sum % 2 != 0) return false;
        int target = sum / 2;
        /** 
         *  dp[i][j]表示从数组的[0, i]下标范围内选取若干个正整数，
         *  是否存在一种方案使得被选取的正整数的和为j。
         */
        boolean[][] dp = new boolean[len][target+1];
        if (nums[0] <= target) dp[0][nums[0]] = true;
        for (int i = 1; i < len; i++) {
            for (int j = 0; j <= target; j++) {
                dp[i][j] = dp[i-1][j]; // 先不选取nums[i]
                if (nums[i] == j) {
                    dp[i][j] = true;
                    continue;
                }
                if (nums[i] < j) { // 可以选取也可以不选取，只要有一种情况为true则为true
                    dp[i][j] = dp[i-1][j] || dp[i-1][j-nums[i]];
                }
            }
        }
        return dp[len-1][target];
    }
}
```

 

## 二、回溯法

### 题目17 [电话号码的字母组合](https://leetcode.cn/problems/letter-combinations-of-a-phone-number/?favorite=2cktkvj)

```java
class Solution {
    HashMap<Character, String> phoneMap = new HashMap<>() {
        {
            put('2', "abc");
            put('3', "def");
            put('4', "ghi");
            put('5', "jkl");
            put('6', "mno");
            put('7', "pqrs");
            put('8', "tuv");
            put('9', "wxyz");
        }
    };
    List<String> res = new ArrayList<>();
    public List<String> letterCombinations(String digits) {
        if(digits == null || digits.length() == 0) return res;
        backtrack(digits, 0, new StringBuffer());
        return res;
    }

    private void backtrack(String digits, int index, StringBuffer temp) {
        if(digits.length() == temp.length()) {
            res.add(temp.toString());
            return;
        }
        String s = phoneMap.get(digits.charAt(index));
        for(int i = 0; i < s.length(); i++) {
            temp.append(s.charAt(i));
            backtrack(digits, index+1, temp);
            temp.deleteCharAt(temp.length()-1);
        }
    }
}
```

### 题目22 [括号生成](https://leetcode.cn/problems/generate-parentheses/?favorite=2cktkvj)

```java
class Solution {
    List<String> list = new ArrayList<>();
    public List<String> generateParenthesis(int n) {
        StringBuffer str = new StringBuffer();
        backtrack(n, str, 0, 0);
        return list;
    }

    private void backtrack(int n, StringBuffer temp, int left, int right) {
        if(right > left) return;
        if(right > n || left > n) return;
        if(right == left && right == n) {
            list.add(temp.toString());
            return;
        }
        temp.append("(");
        backtrack(n, temp, left+1, right);
        temp.deleteCharAt(temp.length()-1);
        temp.append(")");
        backtrack(n, temp, left, right+1);
        temp.deleteCharAt(temp.length()-1);
    }
}
```

### 题目39 [组合总和](https://leetcode.cn/problems/combination-sum/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> combinationSum(int[] candidates, int target) {
        backtrack(candidates, target, new ArrayList<Integer>(), 0, 0);
        return res;
    }
    private void backtrack(int[] candidates, int target, List<Integer> t, int index, int sum) {
        if(sum > target) return;
        if(sum == target) {
            res.add(new ArrayList<>(t));
            return;
        }
        for(int i = index; i < candidates.length; i++) {
            t.add(candidates[i]);
            backtrack(candidates, target, t, i, sum+candidates[i]);
            t.remove(t.size()-1);
        }
    }
}
```

### 题目46 [全排列](https://leetcode.cn/problems/permutations/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    int[] visited;
    public List<List<Integer>> permute(int[] nums) {
        visited = new int[nums.length];
        backtrack(nums, new ArrayList<>());
        return res;
    }
    public void backtrack(int[] nums, List<Integer> t) {
        if(t.size() == nums.length) {
            res.add(new ArrayList<>(t));
            return;
        }
        for(int i = 0; i < nums.length; i++) {
            if(visited[i] == 1) continue;
            visited[i] = 1;
            t.add(nums[i]);
            backtrack(nums, t);
            visited[i] = 0;
            t.remove(t.size()-1);
        }
    }
}
```

### 题目78 [子集](https://leetcode.cn/problems/subsets/)

```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    int[] nums;
    public List<List<Integer>> subsets(int[] nums) {
        this.nums = nums;
        backtrack(0, new ArrayList<>());
        return res;
    }
    private void backtrack(int index, List<Integer> list) {
        if(index > nums.length) return;
        res.add(new ArrayList<>(list));
        for(int i = index; i < nums.length; i++) {
            list.add(nums[i]);
            backtrack(i+1, list);
            list.remove(list.size()-1);
        }
    }
}
```

### 题目79 [单词搜索](https://leetcode.cn/problems/word-search/)

```java
class Solution {
    int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
    public boolean exist(char[][] board, String word) {
        int rows = board.length;
        int cols = board[0].length;
        boolean[][] visited = new boolean[rows][cols];
        for(int row = 0; row < rows; row++) {
            for(int col = 0; col < cols; col++) {
                if(check(board, word, visited, 0, row, col)) {
                    return true;
                }
            }
        }
        return false;
    }
    private boolean check(char[][] board, String word, boolean[][] visited, int k, int row, int col) {
        if(k >= word.length() || board[row][col] != word.charAt(k)) return false;
        if(k == word.length()-1) return true;
        boolean res = false;
        visited[row][col] = true;
        for(int i = 0; i < 4; i++) {
            int newRow = row + directions[i][0];
            int newCol = col + directions[i][1];
            if(newRow < board.length && newCol < board[0].length 
            && newRow >= 0 && newCol >= 0 && !visited[newRow][newCol]) {
                res = check(board, word, visited, k+1, newRow, newCol);
                if(res) break;
            }
        }
        visited[row][col] = false;
        return res;
    }
}
```

### 题目494 [目标和](https://leetcode.cn/problems/target-sum/?favorite=2cktkvj)

```java
class Solution {
    int res = 0;
    public int findTargetSumWays(int[] nums, int target) {
        back(nums, target, 1, nums[0]);
        back(nums, target, 1, -nums[0]);
        return res;
    }

    private void back(int[] nums, int target, int index, int sum) {
        if(index == nums.length && sum == target) {
            res++;
            return;
        }
        if(index >= nums.length) return;
        back(nums, target, index+1, sum+nums[index]);
        back(nums, target, index+1, sum-nums[index]);
    }
}
```

## 三、贪心

### 题目55 [跳跃游戏](https://leetcode.cn/problems/jump-game/?favorite=2cktkvj)

```java
class Solution {
    public boolean canJump(int[] nums) {
        int len = nums.length;
        int max = 0; //维护一个当前能到达的最远距离；
        for(int i = 0; i < len; i++) {
            if(i > max) return false; //当前节点已经比最远距离还远了，后面的节点都到不了
            max = Math.max(max, i+nums[i]);
        }
        return true;
    }
}
```

## 四、树

### 题目94 [二叉树的中序遍历](https://leetcode.cn/problems/binary-tree-inorder-traversal/)

```java
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        if(root == null) return res;
        Deque<TreeNode> stack = new LinkedList<>();
        TreeNode p = root;
        while(!stack.isEmpty() || p != null) {
            if(p != null) {
                stack.push(p);
                p = p.left;
            } else {
                p = stack.pop();
                res.add(p.val);
                p = p.right;
            }
        }
        return res;
    }
}
```

### ☆题目98 [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

```java
class Solution {
    public boolean isValidBST(TreeNode root) {
        if(root == null) return true;
        return dfs(root, Long.MIN_VALUE, Long.MAX_VALUE);
    }
    private boolean dfs(TreeNode root, long min, long max) {
        if(root == null) return true;
        if(root.val <= min || root.val >= max) return false;
        return dfs(root.left, min, root.val) && dfs(root.right, root.val, max);
    }
}
```



### 题目101 [对称二叉树](https://leetcode.cn/problems/symmetric-tree/)

```java
class Solution {
    public boolean isSymmetric(TreeNode root) {
        return check(root.left, root.right);
    }
    private boolean check(TreeNode node1, TreeNode node2) {
        if(node1 == null && node2 == null) return true;
        if(node1 == null || node2 == null) return false;
        return (node1.val == node2.val) && check(node1.left, node2.right) && check(node1.right, node2.left);
    }
}
```

### 题目102 [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        Deque<TreeNode> queue = new LinkedList<>();
        if(root != null) queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            List<Integer> t = new ArrayList<>();
            for(int i = 0; i < size; i++) {
                TreeNode node = queue.poll();
                t.add(node.val);
                if(node.left != null) queue.offer(node.left);
                if(node.right != null) queue.offer(node.right);
            }
            res.add(t);
        }
        return res;
    }
}
```



### 题目104 [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        return Math.max(maxDepth(root.left), maxDepth(root.right))+1;
    }
}
```

### 题目105 [从前序与中序遍历序列构造二叉树](https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)

```java
class Solution {
    Map<Integer, Integer> inMap = new HashMap<>();
    int preIndex = 0;
    public TreeNode buildTree(int[] preorder, int[] inorder) {
        for(int i = 0; i < inorder.length; i++) {
            inMap.put(inorder[i], i);
        }
        TreeNode root = new TreeNode(preorder[preIndex++]);
        root.left = build(preorder, inorder, 0, inMap.get(root.val)-1);
        root.right = build(preorder, inorder, inMap.get(root.val)+1, inorder.length-1);
        return root;
    }
    private TreeNode build(int[] preorder, int[] inorder, int inStart, int inEnd) {
        if(inStart > inEnd) return null;
        TreeNode root = new TreeNode(preorder[preIndex++]);
        root.left = build(preorder, inorder, inStart, inMap.get(root.val)-1);
        root.right = build(preorder, inorder, inMap.get(root.val)+1, inEnd);
        return root;
    }
}
```



### 题目108 [将有序数组转换为二叉搜索树](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

```java
class Solution {
    public TreeNode sortedArrayToBST(int[] nums) {
        if(nums == null || nums.length == 0) return null;
        int len = nums.length;
        int mid = len / 2;
        TreeNode root = new TreeNode(nums[mid]);
        root.left = sortedArrayToBST(subArray(nums, 0, mid));
        root.right = sortedArrayToBST(subArray(nums, mid+1, len));
        return root;
    }
    private int[] subArray(int[] nums, int start, int end) {
        if(end < start) return null;
        return Arrays.copyOfRange(nums, start, end);
    }
}
```

### 题目114 [二叉树展开为链表](https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/)

```java
class Solution {
    List<TreeNode> list = new ArrayList<>();
    public void flatten(TreeNode root) {
        if(root == null) return;
        preScan(root);
        TreeNode tail = root;
        tail.left = null;
        for(int i = 1; i < list.size(); i++) {
            tail.right = list.get(i);
            tail = tail.right;
            tail.left = null;
        }
    }
    private void preScan(TreeNode root) {
        if(root == null) return;
        list.add(root);
        preScan(root.left);
        preScan(root.right);
    }
}
```

 

### 题目199 [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

```java
class Solution {
    public List<Integer> rightSideView(TreeNode root) {
        List<Integer> res = new ArrayList<>();
        Deque<TreeNode> queue = new LinkedList<>();
        if(root == null) return res;
        queue.offer(root);
        while(!queue.isEmpty()) {
            int size = queue.size();
            res.add(queue.peekLast().val);
            for(int i = 0; i < size; i++) {
                TreeNode t = queue.poll();
                if(t.left != null) queue.offer(t.left);
                if(t.right != null) queue.offer(t.right);
            }
        }
        return res;
    }
}
```



### 题目226 [翻转二叉树](https://leetcode.cn/problems/invert-binary-tree/)

```java
class Solution {
    public TreeNode invertTree(TreeNode root) {
        if(root == null) return root;
        TreeNode left = root.left; //要提前记录放置丢失
        TreeNode right = root.right;
        root.left = right;
        root.right = left;
        root.left = invertTree(root.left);
        root.right = invertTree(root.right);
        return root;
    }
}
```

### 题目230 [二叉搜索树中第K小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

```java
class Solution {
    List<Integer> list = new ArrayList<>();
    int k;
    public int kthSmallest(TreeNode root, int k) {
        this.k = k;
        midTrace(root);
        return list.get(list.size()-1);
    }
    private void midTrace(TreeNode root) {
        if(root == null) return;
        midTrace(root.left);
        if(list.size() == k) return;
        list.add(root.val);
        midTrace(root.right);
    }
}
```

### 题目236 [二叉树的最近公共祖先](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

```java
class Solution {
    HashMap<Integer, TreeNode> map = new HashMap<>();
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null) return null;
        preScan(root);
        Set<Integer> pSet = new HashSet<>();
        while(p != null) {
            pSet.add(p.val);
            p = map.get(p.val);
        }
        while(!pSet.contains(q.val)) 
            q = map.get(q.val);
        return q;
    }
    private void preScan(TreeNode root) {
        if(root == null) return;
        if(root.left != null) {
            map.put(root.left.val, root);
            preScan(root.left);
        }
        if(root.right != null) {
            map.put(root.right.val, root);
            preScan(root.right);
        }
    }
}
```



### ☆题目437 [路径总和 III](https://leetcode.cn/problems/path-sum-iii/)

```java
class Solution {
    int res = 0;
    long targetSum;
    Set<TreeNode> set = new HashSet<>();
    public int pathSum(TreeNode root, int targetSum) {
        this.targetSum = targetSum;
        if(root == null) return res;
        dfs(root, 0L);
        return res;
    }
    private void dfs(TreeNode root, long preSum) {
        if(root == null) return;
        if(root.val + preSum == targetSum) {
            res++;
        }
        if(root.left != null) {
            dfs(root.left, preSum+root.val);
            if(!set.contains(root.left)){
                set.add(root.left);
                dfs(root.left, 0L);
            }
        }
        if(root.right != null) {
            dfs(root.right, preSum+root.val);
            if(!set.contains(root.right)) {
                set.add(root.right);
                dfs(root.right, 0L);
            }
        }
    }
}
```



### 题目543 [二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

```java
class Solution {
    int max = Integer.MIN_VALUE;
    public int diameterOfBinaryTree(TreeNode root) {
        if (root == null) return 0;
        treeHeight(root);
        return max;
    }
    private int treeHeight(TreeNode root) {
        if (root == null) return 0;
        int leftHeight = treeHeight(root.left);
        int rightHeight = treeHeight(root.right);
        if(leftHeight + rightHeight > max) {
            max = leftHeight + rightHeight;
        }
        return Math.max(leftHeight, rightHeight) + 1;
    }
}
```



## 六、链表

### 题目2 [两数相加](https://leetcode.cn/problems/add-two-numbers/?favorite=2cktkvj)

```java
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        int carry = 0;
        ListNode p = l1, q = l2;
        ListNode tail = l1;;
        while(p != null && q != null) {
            if(p.next == null) tail = p;
            int sum = p.val + q.val + carry;
            if(sum >= 10) {
                sum -= 10;
                carry = 1;
            } else {
                carry = 0;
            }
            p.val = sum; // 无额外空间
            p = p.next;
            q = q.next;
        }
        if(q != null) {
            tail.next = q;
            p = tail.next;
        }
        while(p != null) {
            if(p.next == null) tail = p;
            int sum = p.val + carry;
            if(sum >= 10) {
                sum -= 10;
                carry = 1;
            } else {
                carry = 0;
            }
            p.val = sum;
            p = p.next;
        }
        if(carry == 1) {
            tail.next = new ListNode(1);
        }
        return l1;
    }
}
```

### 题目19 [删除链表的倒数第 N 个结点](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?favorite=2cktkvj)

```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode H = new ListNode();
        H.next = head;
        ListNode fast = H, prev = H;
        for(int i = 0; i < n; i++) {
            fast = fast.next;
        }
        while(fast.next != null) {
            fast = fast.next;
            prev = prev.next;
        }
        prev.next = prev.next.next;
        return H.next;
    }
}
```

### 题目21 [合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists/?favorite=2cktkvj)

```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode l1 = list1, l2 = list2;
        ListNode head = new ListNode();
        ListNode tail = head;
        while(l1 != null && l2 != null) {
            if(l1.val <= l2.val) {
                tail.next = l1;
                l1 = l1.next;
            } else {
                tail.next = l2;
                l2 = l2.next;
            }
            tail = tail.next;
            tail.next = null;
        }
        if(l1 != null)
            tail.next = l1;
        if(l2 != null) 
            tail.next = l2;
        return head.next;
    }
}
```

### 题目24  [两两交换链表中的节点](https://leetcode.cn/problems/swap-nodes-in-pairs/)

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        if(head == null || head.next == null) return head;
        ListNode p = head;
        head = p.next;
        ListNode pre = null;
        while(p != null && p.next != null) {
            ListNode q = p.next;
            p.next = q.next;
            q.next = p;
            if(pre != null) {
                pre.next = q;
            }
            pre = p;
            p = p.next;
        }
        return head;
    }
}
```

### 题目138 [复制带随机指针的链表](https://leetcode.cn/problems/copy-list-with-random-pointer/)

```java
class Solution {
    public Node copyRandomList(Node head) {
        if(head == null) return head;
        HashMap<Node, Node> map = new HashMap<>();
        Node p = head;
        while(p != null) {
            map.put(p, new Node(p.val));
            p = p.next;
        }
        p = head;
        while(p != null) {
            map.get(p).next = map.get(p.next);
            map.get(p).random = map.get(p.random);
            p = p.next;
        }
        return map.get(head);
    }
}
```



### 题目141 [环形链表](https://leetcode.cn/problems/linked-list-cycle/)

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) return true;
        }
        return false;
    }
}
```

### 题目142 [环形链表 II](https://leetcode.cn/problems/linked-list-cycle-ii/)

```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head, slow = head;
        while(fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            if(fast == slow) {
                break;
            }
        }
        if(fast == null || fast.next == null) return null;
        fast = head;
        while(fast != slow) {
            fast = fast.next;
            slow = slow.next;
        }
        return fast;
    }
}
```

### ☆题目146 [LRU 缓存](https://leetcode.cn/problems/lru-cache/)

```java
class LRUCache {
    private int capacity;
    private int size;
    private Node head;
    private HashMap<Integer, Node> cache;
    public LRUCache(int capacity) {
        this.capacity = capacity;
        this.size = 0;
        this.head = new Node();
        this.head.prev = this.head;
        this.head.next = this.head;
        this.cache = new HashMap<>();
    }
    public int get(int key) {
        Node node = this.cache.get(key);
        if(node == null) return -1;
        node = node.remove();
        this.head.insert(node);
        return node.val;
    }
    public void put(int key, int value) {
        Node node = this.cache.get(key);
        if(node == null) {
            node = new Node(key, value);
            this.cache.put(key, node);
            size++;
        } else {
            node = node.remove();
            node.val = value;
        }
        this.head.insert(node);
        if(this.size > this.capacity) {
            Node removedNode = this.head.prev.remove();
            this.cache.remove(removedNode.key);
            this.size--;
        }
    }
}
class Node {
    int key;
    int val;
    Node next;
    Node prev;
    Node () {}
    Node(int key, int val) {
        this.key = key;
        this.val = val;
    }
    Node remove() {
        this.prev.next = next;
        this.next.prev = prev;
        next = null;
        prev = null;
        return this;
    }
    void insert(Node node) { //在该节点后插入node节点
        node.next = next;
        node.prev = this;
        this.next.prev = node;
        this.next = node;
    }
}
```



### 题目148 [排序链表](https://leetcode.cn/problems/sort-list/)

```java
class Solution {
    public ListNode sortList(ListNode head) {
        List<Integer> list = new ArrayList<>();
        for(ListNode i = head; i != null; i = i.next) 
            list.add(i.val);
        list.sort(new Comparator<Integer>(){
            public int compare(Integer o1, Integer o2) {
                return o1 - o2;
            }
        });
        int index = 0;
        for(ListNode i = head; i != null; i = i.next) 
            i.val = list.get(index++);
        return head;
    }
}
```



### 题目160 [相交链表](https://leetcode.cn/problems/intersection-of-two-linked-lists/)

```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p = headA, q = headB;
        int lenA = 0, lenB = 0;
        while(p != null) {
            p = p.next;
            lenA++;
        }
        while(q != null) {
            q = q.next;
            lenB++;
        }
        if(lenA >= lenB) {
            p = headA;
            q = headB;
        } else {
            p = headB;
            q = headA;
        }
        for(int i = 0; i < Math.abs(lenA - lenB); i++) {
            p = p.next;
        }
        while(p != null && q != null) {
            if(p == q) return p;
            else {
                p = p.next;
                q = q.next;
            }
        }
        return null;
    }
}
```

### 题目206 [反转链表](https://leetcode.cn/problems/reverse-linked-list/)

```java
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode H = new ListNode();
        ListNode p = head;
        while(p != null) {
            ListNode q = p.next;
            p.next = H.next;
            H.next = p;
            p = q;
        }
        return H.next;
    }
}
```

### 题目234 [回文链表](https://leetcode.cn/problems/palindrome-linked-list/)

```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode p = head, q = head;
        while(q != null && q.next != null) {
            if(q.next.next != null) {
                p = p.next;
                q = q.next.next;
            } else q = q.next;
        }
        q = reverse(p);
        p.next = null;
        p = head;
        while(p != null) {
            if(p.val != q.val) return false;
            p = p.next;
            q = q.next;
        }
        return true;
    }
    private ListNode reverse(ListNode h) {
        ListNode head = new ListNode();
        ListNode p = h;
        while(p != null) {
            ListNode q = p.next;
            p.next = head.next;
            head.next = p;
            p = q;
        }
        return head.next;
    }
}
```



## 七、二分查找

### 题目33 [搜索旋转排序数组](https://leetcode.cn/problems/search-in-rotated-sorted-array/?favorite=2cktkvj)

```java
class Solution {
    public int search(int[] nums, int target) {
        int len = nums.length;
        if(len == 0) return -1;
        if(len == 1) return nums[0] == target ? 0 : -1;
        int left = 0, right = len - 1;
        while(left <= right) {
            int mid = (left + right) / 2;
            if(nums[mid] == target) return mid;
            if(nums[0] <= nums[mid]) {
                if(nums[0] <= target && target <= nums[mid]) {
                    right = mid-1;
                } else {
                    left = mid+1;
                }
            } else {
                if(nums[mid] < target && target <= nums[len - 1]) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
        }
        return -1;
    }
}
```

### 题目34 [在排序数组中查找元素的第一个和最后一个位置](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/)

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int[] res = new int[]{-1, -1};
        if(nums == null || nums.length == 0) return res;
        int left = 0, right = nums.length-1;
        while(left <= right) {
            int mid = left + (right - left) / 2;
            if(nums[mid] == target) {
                while(mid > 0 && nums[mid-1] == nums[mid]) mid--;
                res[0] = mid;
                while(mid < nums.length-1 && nums[mid+1] == nums[mid]) mid++;
                res[1] = mid;
                return res;
            } else if(nums[mid] < target) {
                left = mid + 1;
            } else right = mid - 1;
        }
        return res;
    }
}
```

## 八、双指针

### 题目283 [移动零](https://leetcode.cn/problems/move-zeroes/)

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int left = 0, right = 0;
        while(left < nums.length && right < nums.length) {
            while(left < nums.length && nums[left] != 0) left++;
            while(right < nums.length && nums[right] == 0) right++;
            swap(nums, left, right);
            right++;
        }
    }
    public void swap(int[] nums, int L, int R) {
        if (L < 0 || L >= nums.length || R < 0 || R >= nums.length || L >= R) return;
        int t = nums[R];
        nums[R] = nums[L];
        nums[L] = t;

    }
}
```



## 其他

### 题目1 [两数之和](https://leetcode.cn/problems/two-sum/?favorite=2cktkvj)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        int[] res = new int[2];
        HashMap<Integer, Integer> map = new HashMap<>();
        for(int i = 0; i < nums.length; i++) {
            if(map.containsKey(target - nums[i])) {
                res[0] = map.get(target - nums[i]);
                res[1] = i;
                return res;
            }
            map.put(nums[i], i);
        }
        return res;
    }
}
```

### 题目3 [无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/?favorite=2cktkvj)

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        int maxLength = 0;
        HashSet<Character> set = new HashSet<>();
        int left = 0, right = 0;
        for(; right < s.length(); right++) {
            while(set.contains(s.charAt(right))) {
                set.remove(s.charAt(left++));
            }
            set.add(s.charAt(right));
            maxLength = Math.max(maxLength, right-left+1);
        }
        return maxLength;
    }
}
```

### 题目11 [盛最多水的容器](https://leetcode.cn/problems/container-with-most-water/?favorite=2cktkvj)

```java
class Solution {
    public int maxArea(int[] height) {
        int max = 0;
        int left = 0, right = height.length-1;
        while(left < right) {
            int area = (right-left) * Math.min(height[left], height[right]);
            if(area > max) max = area;
            if(height[left] <= height[right]) left++;
            else right--;
        }
        return max;
    }
}
```

### 题目15 [三数之和](https://leetcode.cn/problems/3sum/?favorite=2cktkvj)

```java
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> res = new ArrayList<>();
        int len = nums.length;
        Arrays.sort(nums);
        for(int i = 0; i < len-2; i++) {
            if(nums[i] > 0) break;
            if(i > 0 && nums[i] == nums[i-1]) continue;
            int left = i+1, right = len-1;
            while(left < right) {
                if(nums[i]+nums[left]+nums[right] == 0) {
                    List<Integer> t = new ArrayList<>();
                    t.add(nums[i]);
                    t.add(nums[left]);
                    t.add(nums[right]);
                    res.add(new ArrayList(t));
                    left++;
                    while(left < len && nums[left] == nums[left-1]) left++;
                    right--;
                    while(right >= 0 && nums[right] == nums[right+1]) right--;
                } else if(nums[i]+nums[left]+nums[right] < 0) {
                    left++;
                } else {
                    right--;
                }
            }
        }
        return res;
    }
}
```

### 题目20 [有效的括号](https://leetcode.cn/problems/valid-parentheses/?favorite=2cktkvj)

```java
class Solution {
    public boolean isValid(String s) {
        Deque<Character> stack = new LinkedList<>();
        int len = s.length();
        for(int i = 0; i < len; i++) {
            char c = s.charAt(i);
            if(c == '(' || c == '{' || c == '[') {
                stack.push(c);
            } else {
                if(stack.isEmpty()) return false;
                char t = stack.pop();
                if(c == ')' && t != '(' ||
                    c == '}' && t != '{' ||
                    c == ']' && t != '[')
                    return false;
            }
        }
        return stack.isEmpty() ? true : false;
    }
}
```

### ★题目31 [下一个排列](https://leetcode.cn/problems/next-permutation/?favorite=2cktkvj) 

```java
class Solution {
    public void nextPermutation(int[] nums) {
        int i = nums.length - 2;
        while(i >= 0 && nums[i] >= nums[i+1]) { //从后向前找到第一个正序相邻对
            i--;
        }
        if(i >= 0) {
            int j = nums.length-1;
            while(j >= 0 && nums[i] >= nums[j]) { //再从后向前找第一个比nums[i]大的数
                j--;
            }
            swap(nums, i, j);
        } 
        reverse(nums, i+1); //后部分逆序，若i<0则整体逆序
    }

    public void swap(int[] nums, int i, int j) {
        int t = nums[i];
        nums[i] = nums[j];
        nums[j] = t;
    }

    public void reverse(int[] nums, int start) {
        int end = nums.length-1;
        while(start < end) {
            swap(nums, start, end);
            start++;
            end--;
        }
    }
}
```

### 题目48 [旋转图像](https://leetcode.cn/problems/rotate-image/)

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        // 1 沿着--中线翻转
        for(int row = 0; row < n/2; row++) {
            for(int col = 0; col < n; col++) {
                int t = matrix[row][col];
                matrix[row][col] = matrix[n-1-row][col];
                matrix[n-1-row][col] = t;
            }
        }
        // 2 沿着↘对角线翻转
        for(int row = 0; row < n; row++) {
            for(int col = 0; col < row; col++) {
                int t = matrix[row][col];
                matrix[row][col] = matrix[col][row];
                matrix[col][row] = t;
            }
        }
    }
}
```

### 题目49 [字母异位词分组](https://leetcode.cn/problems/group-anagrams/)

```java
class Solution {
    public List<List<String>> groupAnagrams(String[] strs) {
        List<List<String>> res = new ArrayList<>();
        HashMap<String, Integer> map = new HashMap<>();
        int index = 0;
        for(int i = 0; i < strs.length; i++) {
            char[] c = strs[i].toCharArray();
            Arrays.sort(c);
            String t = new String(c);
            if(map.containsKey(t)) {
                List<String> list = res.get(map.get(t));
                list.add(strs[i]);
            } else {
                map.put(t, index++);
                List<String> list = new ArrayList<>();
                list.add(strs[i]);
                res.add(list);
            }
        }
        return res;
    }
}
```

### 题目54 [螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)

```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> res = new ArrayList<>();
        int rows = matrix.length;
        int cols = matrix[0].length;
        int count = 0;
        while(res.size() < rows*cols) {
            int row = 0+count;
            int col = 0+count;
            for(; col < cols-count; col++) {
                res.add(matrix[row][col]);
            }
            if(res.size() >= rows*cols) break;
            col--;
            row++;
            for(; row < rows-count; row++) {
                res.add(matrix[row][col]);
            }
            if(res.size() >= rows*cols) break;
            row--;
            col--;
            for(; col >= 0+count; col--) {
                res.add(matrix[row][col]);
            }
            if(res.size() >= rows*cols) break;
            col++;
            row--;
            count++;
            for(; row >= 0+count; row--) {
                res.add(matrix[row][col]);
            }
        }
        return res;
    }
}
```



### 题目56 [合并区间](https://leetcode.cn/problems/merge-intervals/)

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        Arrays.sort(intervals, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                return o1[0] - o2[0];
            }
        });
        List<int[]> res = new ArrayList<>();
        int[] pre = intervals[0];
        for(int i = 1; i < intervals.length; i++) {
            int[] t = intervals[i];
            if(t[0] <= pre[1]) {
                pre[1] = Math.max(t[1], pre[1]);
            } else {
                res.add(pre);
                pre = t;
            }
        }
        res.add(pre);
        return res.toArray(new int[res.size()][2]);
    }
}
```

### 题目73 [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/)

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        List<int[]> zeroPoint = new ArrayList<>();
        for(int i = 0; i < rows; i++)
            for(int j = 0; j < cols; j++)
                if(matrix[i][j] == 0)
                    zeroPoint.add(new int[]{i, j});
        boolean[] rowFlag = new boolean[rows];
        boolean[] colFlag = new boolean[cols];
        for(int i = 0; i < zeroPoint.size(); i++) {
            int row = zeroPoint.get(i)[0];
            int col = zeroPoint.get(i)[1];
            if(!rowFlag[row]) {
                for(int c = 0; c < cols; c++) 
                    matrix[row][c] = 0;
                rowFlag[row] = true;
            }
            if(!colFlag[col]) {
                for(int r = 0; r < rows; r++)
                    matrix[r][col] = 0;
                colFlag[col] = true;
            }
        }
    }
}
```



### 题目75 [颜色分类](https://leetcode.cn/problems/sort-colors/)

```java
class Solution {
    public void sortColors(int[] nums) {
        quickSort(nums, 0, nums.length-1);
    }
    private void quickSort(int[] nums, int left, int right) {
        if(left < right) {
            int index = partition(nums, left, right);
            quickSort(nums, left, index-1);
            quickSort(nums, index+1, right);
        }
    }
    private int partition(int[] nums, int left, int right) {
        int target = nums[left];
        while(left < right) {
            while(left < right && nums[right] >= target) right--;
            nums[left] = nums[right];
            while(left < right && nums[left] <= target) left++;
            nums[right] = nums[left];
        }
        nums[left] = target;
        return left;
    }
}
```

### ★题目128 [最长连续序列](https://leetcode.cn/problems/longest-consecutive-sequence/)

```java
class Solution {
    public int longestConsecutive(int[] nums) {
        if(nums == null || nums.length == 0) return 0;
        int res = 1;
        Set<Integer> set = new HashSet<>();
        for(int num : nums) {
            set.add(num);
        }
        for(int num : set) {
            if(!set.contains(num-1)) {
                int len = 1;
                int curNum = num;
                while(set.contains(num+1)) {
                    len++;
                    num++;
                    res = Math.max(res, len);
                }
            }
        }
        return res;
    }
}
```

### 题目189 [轮转数组](https://leetcode.cn/problems/rotate-array/)

```java
class Solution {
    public void rotate(int[] nums, int k) {
        int len = nums.length;
        k = k % len;
        int disLen = len - k;
        int[] t = new int[k];
        int index = 0;
        for(int i = disLen; i < len; i++) {
            t[index++] = nums[i];
        }
        index = len-1;
        for(int i = disLen-1; i >= 0; i--) {
            nums[index--] = nums[i];
        }
        for(int i = 0; i < k; i++) {
            nums[i] = t[i];
        }
    }
}
```

### 题目238 [除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)

```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int[] L = new int[nums.length];
        int[] R = new int[nums.length];
        L[0] = 1;
        R[R.length-1] = 1;
        for(int i = 1; i < L.length; i++) {
            L[i] = L[i-1] * nums[i-1];
        }
        for(int i = R.length-2; i >= 0; i--) {
            R[i] = R[i+1] * nums[i+1];
        }
        for(int i = 0; i < nums.length; i++) {
            nums[i] = L[i] * R[i];
        }
        return nums;
    }
}
```

### 题目240 [搜索二维矩阵 II](https://leetcode.cn/problems/search-a-2d-matrix-ii/)

```java
class Solution { //矩阵的二分，更简单的方法有每行二分
    public boolean searchMatrix(int[][] matrix, int target) {
        int rows = matrix.length;
        int cols = matrix[0].length;
        return searchPartMatrix(matrix, 0, rows-1, 0, cols-1, target);
    }
    private boolean searchPartMatrix(int[][] matrix, int startRow, int endRow, int startCol, int endCol, int target) {
        if(startRow > endRow || startCol > endCol) return false;
        if(startRow == endRow && startCol == endCol) return target==matrix[startRow][startCol];
        int midRow = startRow + (endRow - startRow) / 2;
        int midCol = startCol + (endCol - startCol) / 2;
        if(midRow == startRow && midCol == startCol) return search(matrix, startRow, endRow, startCol, endCol, target);
        int t = matrix[midRow][midCol];
        if(t == target) return true;
        else if(t > target) {
            return searchPartMatrix(matrix, startRow, midRow-1, startCol, midCol-1, target) || searchPartMatrix(matrix, startRow, midRow-1, midCol, endCol, target) || searchPartMatrix(matrix, midRow, endRow, startCol, midCol-1, target);
        } else {
            return searchPartMatrix(matrix, midRow, endRow, midCol, endCol, target) || searchPartMatrix(matrix, startRow, midRow-1, midCol, endCol, target) || searchPartMatrix(matrix, midRow, endRow, startCol, midCol-1, target);
        }
    }
    private boolean search(int[][] matrix, int startRow, int endRow, int startCol, int endCol, int target) {
        for(int i = startRow; i <= endRow; i++) {
            for(int j = startCol; j <= endCol; j++) {
                if(matrix[i][j] == target) return true;
            }
        }
        return false;
    }
}
```



### 题目438 [找到字符串中所有字母异位词](https://leetcode.cn/problems/find-all-anagrams-in-a-string/)

```java
class Solution {
    public List<Integer> findAnagrams(String s, String p) {
        List<Integer> res = new ArrayList<>();
        int sLen = s.length(), pLen = p.length();
        if(sLen < pLen) return res;
        int[] sCount = new int[26];
        int[] pCount = new int[26];
        for(int i = 0; i < pLen; i++) {
            sCount[s.charAt(i)-'a']++;
            pCount[p.charAt(i)-'a']++;
        }
        if(Arrays.equals(sCount, pCount)) 
            res.add(0);
        for(int i = 0; i < sLen - pLen; i++) {
            sCount[s.charAt(i)-'a']--;
            sCount[s.charAt(i+pLen)-'a']++;
            if(Arrays.equals(sCount, pCount)) {
                res.add(i+1);
            }
        }
        return res;
    }
}
```

### ★题目560 [和为 K 的子数组](https://leetcode.cn/problems/subarray-sum-equals-k/)

```java
class Solution {
    public int subarraySum(int[] nums, int k) {
        int len = nums.length;
        int preSum = 0;
        int count = 0;
        Map<Integer, Integer> map = new HashMap<>();
        map.put(0, 1);
        for(int num : nums) {
            preSum += num;
            count += map.getOrDefault(preSum-k, 0); //前缀和preSum-k
            map.put(preSum, map.getOrDefault(preSum, 0)+1);
        }
        return count;
    }
}
```



### 题目647 [回文子串](https://leetcode.cn/problems/palindromic-substrings/?favorite=2cktkvj)

```java
class Solution {
    int res;
    public int countSubstrings(String s) {
        int len = s.length();
        for(int i = 0; i < len; i++) {
            f(s, i, i);
            f(s, i, i+1);
        }
        return res;
    }
    private void f(String s, int left, int right) {
        int len = s.length();
        while(left >= 0 && right < len) {
            if(s.charAt(left) != s.charAt(right)) break;
            res++;
            left--;
            right++;
        }
    }
}
```